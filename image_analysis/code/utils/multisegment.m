function multisegment(p)
    disp('Analyzing...')
    
    if ~isfield(p, 'out_prefix')
        p.out_prefix = '';
    end
    
    if isfield(p, 'in_path')
        in_path = [p.in_path p.out_prefix 'corrected_data/'];
        out_path = [p.out_path p.out_prefix 'segmentations/'];
    elseif isfield(p, 'corrected_data_path')
        in_path = p.corrected_data_path;
        out_path = [p.path p.out_prefix 'segmentations/'];
    else
        in_path = [p.path p.out_prefix 'corrected_data/'];
        out_path = [p.path p.out_prefix 'segmentations/'];
    end
    
    if isfield(p, 'time_plates')
        plates = p.time_plates;
    else
        plates = repmat({''},size(p.time_names));
    end
    
    if isfield(p, 'im_X')
        im_X = p.im_X;
        im_Y = p.im_Y;
    else
        im_X = 1080;
        im_Y = 1080;
    end
    
    mkdir(out_path)
        
    for t = 1:length(p.time_names)
        row=p.time_names{t};
        plate = plates{t};
        for d = 1:length(p.density_names)
            col = p.density_names{d};
            
            file_info = dir([in_path plate row col '*.mat']);
            parfor f = 1:length(file_info) %parallel
                file = file_info(f).name;
                disp(file)
                loaded_im = load([in_path file],'current_im');
                current_im = loaded_im.current_im;
                
                %segment with standard 2D-segmentation
                seg = struct();
                for ch = 1:length(p.channels)
                    
                    ch_seg = zeros(p.im_X,p.im_Y,length(p.slices));
                    
                    if isfield(p,['seg_' p.channels{ch}]) %if need segmentation for this channel, do it
                        
                        for slice = p.slices
                            im = current_im(ch).im(:,:,slice);
                            
                            %get a correction/filtering secondary image to give to the segfun if needed
                            if isfield(p.(['seg_' p.channels{ch}]),'max_autofluor')
                                im_correction = current_im(p.array_channel).im(:,:,slice);
                            elseif isfield(p.(['seg_' p.channels{ch}]),'CTV_GFP_comp')
                                im_correction = current_im(p.cell_channel).im(:,:,slice)*p.CTV_GFP_comp;
                            else
                                im_correction = zeros(im_X,im_Y);
                            end
                            
                            %segment the slice
                            ch_seg(:,:,slice) = feval(p.(['seg_' p.channels{ch}]).segfun,im,im_correction,p.(['seg_' p.channels{ch}]));
                        end
                        
                        %apply any required 3D corrections to the segmentation
                        if isfield(p.(['seg_' p.channels{ch}]),'close3D')
                            
                            close3D = p.(['seg_' p.channels{ch}]).close3D;
                            %clean up 3D cell segmentation to get rid of artifactul protrusions generated by image noise
                            [x,y,z] = ndgrid(-close3D:close3D);
                            se = strel(sqrt(x.^2 + y.^2 + z.^2) <= close3D);
                            ch_seg = imopen(ch_seg,se);

                            if any(ch_seg,'all') %if any cells left
                                % filter out cells that are not present in minimum number of z-slice
                                props = regionprops3(logical(ch_seg),'BoundingBox','VoxelIdxList');
                                idxs = props.VoxelIdxList(props.BoundingBox(:,6) < p.(['seg_' p.channels{ch}]).min_n_slices);
                                idxs = cat(1,idxs{:});
                                ch_seg(idxs) = 0;
                            end
                        end

                        if isfield(p.(['seg_' p.channels{ch}]),'array_3D_open') && p.(['seg_' p.channels{ch}]).array_3D_open
                            %clean up 3D array segmentation to get rid of image noise
                            base_grid = zeros([3,3,3]);
                            base_grid(:,2,2) = 1;
                            base_grid(2,:,2) = 1;

                            se_grid1 = base_grid;
                            se_grid1(2,2,1) = 1;
                            se1 = strel(se_grid1);
                            se_grid2 = base_grid;
                            se_grid2(2,2,3) = 1;
                            se2 = strel(se_grid2);
                            ch_seg = imopen(ch_seg,se1) | imopen(ch_seg,se2);
                        end
                    end
                    seg.(p.channels{ch}) = ch_seg;
                end
                save_seg([out_path file],seg)
            end
        end
    end
end

function save_seg(location,seg)
    save(location,'seg','-v7.3')
end
load('D:\wlwhite\image_processing\20211112_full_array_density_range\params.mat','p')

pos = 'B2-0-1';
slice = 1;

load([p.path '\corrected_data\' pos '.mat'])
seg = zeros(1080,1080,max(p.slices));

p.cell_channel = 2; % fluorescent channel for CTV
p.mindist = 2;   % minimum value for the watershed minima
p.min_val = 300;   % pixel intensity quantile  of background
p.max_val = 3000;   %pixel initensity quantile of max foreground value
p.minsize = 2300;   % minimum size of a cell (area in pixels)
p.maxsize = 45000; % maximum size of a cell (area in pixels)
p.maxecc = 4;    % the maximum eccentricity of a cell
p.unsharp_size = 7;  % 'size' of the unsharp filter
p.unsharp_alpha = 0.8;  % degree of unsharp filtering between 0.2 and 0.9
p.laplace_cutoff = -0.0007; %maximum acceptible value of laplacian
p.gauss_size = 25; %size of gaussian blur
p.gauss_std = 10; %stdev of gaussian blur
p.close1 = 6; %size of diamond for first close operation (after laplacian threshholding)
p.open1 = 12; %size of disk to use for open operation to remove debris
p.max_hull_area = 20;
p.min_hull_ratio = 0.2;
p.dilate = 2; %size of disk to dilate cell borders by at end of segmentation
p.min_brightness = 1500; % the mininmum required mean pixel intensity in a cell
p.close3D = 1; %radius to use for close operation on full z-stack after all 2D segmentation is done

for i = p.slices
     cell_im = current_im(p.cell_channel).im(:,:,i);
    if p.WGA_GFP_comp > 0
        cell_im = max(0,cell_im - p.WGA_GFP_comp.*current_im(p.array_channel).im(:,:,i));
    end
    if i == slice
        seg(:,:,i) = cellseg(cell_im,p,true);
    else
        seg(:,:,i) = cellseg(cell_im,p);
    end
end
%clean up 3D cell segmentation to get rid of artifactul protrusions generated by image noise
[x,y,z] = ndgrid(-p.close3D:p.close3D);
se = strel(sqrt(x.^2 + y.^2 + z.^2) <= p.close3D);
seg = imopen(seg,se);

% filter out cells that are not present inevery z-slice
if any(seg,'all')
    props = regionprops3(logical(seg),'BoundingBox','VoxelIdxList');
    idxs = props.VoxelIdxList(props.BoundingBox(:,6)<p.min_n_slices);
    idxs = cat(1,idxs{:});
    seg(idxs) = 0;
end

figure()
imshow(adjust_val(current_im(p.cell_channel).im(:,:,slice),p.min_val,p.max_val))
hold on
perims = bwboundaries(seg(:,:,slice));
for i = 1:length(perims)
    perim = perims{i};
    plot(perim(:,2), perim(:,1), 'Color', 'r', 'LineWidth', 1)
end

figure()
imshow(adjust(current_im(1).im(:,:,slice),0.001,0.999))
hold on
perims = bwboundaries(seg(:,:,slice));
for i = 1:length(perims)
    perim = perims{i};
    plot(perim(:,2), perim(:,1), 'Color', 'r', 'LineWidth', 1)
end


function out = adjust(im,q_low,q_high)
    low = quantile(im(:),q_low);
    high = quantile(im(:),q_high);

    out = imadjust(im./high,[low/high; 1],[0 ; 1]);
end

function out = adjust_val(im,low,high)
    out = imadjust(im./high,[low/high; 1],[0 ; 1]);
end